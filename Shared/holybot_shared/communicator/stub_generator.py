import sys
import os
import inspect
import importlib.util
import importlib.abc
from pathlib import Path

from holybot_shared.communicator import Client


class StubGenerator:
    @staticmethod
    def generate_class_stub(client: Client) -> str:
        original_class = client._wrapped_class_ref
        if original_class is None:
            return ""

        class_name = client._Client__name
        # class_name = original_class.__name__
        lines = [
            "from holybot_shared.communicator.microservice import Microservice",
            "import holybot_shared.SharedProto.holybot.api",
            "\n",
            f"class {class_name}(Microservice):",
        ]

        def write_method(name, func):
            sig = inspect.signature(func)

            if sig.return_annotation is not inspect.Signature.empty:

                timeout_param = inspect.Parameter(
                    "timeout",
                    inspect.Parameter.KEYWORD_ONLY,
                    default=10,
                    annotation=int,
                )

                new_params = list(sig.parameters.values())

                inserted = False
                for i, param in enumerate(new_params):
                    if param.kind == inspect.Parameter.VAR_KEYWORD:
                        new_params.insert(i, timeout_param)
                        inserted = True
                        break

                if not inserted:
                    new_params.append(timeout_param)
                new_sig = sig.replace(parameters=new_params)
            else:
                new_sig = sig.replace(return_annotation=None)

            lines.append(f"    async def {name}{str(new_sig)}:")
            lines.append("        ...")
            lines.append("")

        for name, func in client.get_registered_events().items():
            write_method(name, func)

        return "\n".join(lines)


def scan_project(root_folder: str):
    abs_root = os.path.abspath(root_folder)
    sys.path.insert(0, abs_root)

    print(f"--- Scanning folder: {abs_root} ---")

    all_stubs = []

    SKIP_DIRS = {
        "venv",
        ".venv",
        "env",
        ".env",
        ".git",
        ".hg",
        ".svn",
        "__pycache__",
        "node_modules",
        "site-packages",
        "dist",
        "build",
        ".mypy_cache",
        ".pytest_cache",
    }

    for dirpath, dirs, filenames in os.walk(abs_root):
        dirs[:] = [d for d in dirs if d not in SKIP_DIRS and not d.startswith(".")]

        for file in filenames:
            if file.endswith(".py") and file != os.path.basename(__file__):
                full_path = os.path.join(dirpath, file)
                process_file(full_path, all_stubs)

    output_file = Path(__file__).parent / "stub.py"
    with open(output_file, "w") as f:
        f.write("# Auto-generated stubs\n")
        f.write("# DO NOT EDIT THIS FILE\n")
        f.write("# Implementation are in the microservice.py\n\n")
        f.write("\n\n".join(all_stubs))

    print(f"\n[Done] Generated stubs for {len(all_stubs)} classes in '{output_file}'")


def process_file(file_path, results_list):
    module_name = os.path.splitext(os.path.basename(file_path))[0]

    max_retries = 5
    for attempt in range(max_retries):
        try:
            spec = importlib.util.spec_from_file_location(module_name, file_path)
            if not spec or not spec.loader:
                return

            module = importlib.util.module_from_spec(spec)
            sys.modules[module_name] = module

            spec.loader.exec_module(module)

            for name, obj in vars(module).items():
                if "_wrapped_class_ref" in dir(obj):

                    if obj._wrapped_class_ref:
                        print(
                            f" -> Found Client in {os.path.basename(file_path)}: Wraps '{obj._wrapped_class_ref.__name__}'"
                        )
                        stub = StubGenerator.generate_class_stub(obj)
                        results_list.append(stub)

            break

        except Exception as e:
            print(f"Skipped {os.path.basename(file_path)} due to error: {e}")
            break


if __name__ == "__main__":
    scan_project(".")
